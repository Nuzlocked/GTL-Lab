const fs = require('fs/promises');
const fsSync = require('fs');
const path = require('path');
const axios = require('axios');
const sharp = require('sharp');

const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2/pokemon';
const TOTAL_POKEMON_GEN5 = 649;

// --- Configuration ---
const outputDir = path.resolve(__dirname, '../public/sprites');
const dataFilePath = path.resolve(__dirname, '../src/data/pokemon-data.ts');
const SUPABASE_PROJECT_ID = 'zixawdogatrcxmxytsbr'; // Replace if needed
const SUPABASE_SPRITE_URL_BASE = `https://${SUPABASE_PROJECT_ID}.supabase.co/storage/v1/object/public/sprites/`;
const DOWNLOAD_CONCURRENCY = 20;
// --------------------

// List of Pokémon to exclude from the download and data generation
const EXCLUDED_POKEMON = new Set([
  'mew', 'mewtwo', 'lugia', 'ho-oh', 'celebi', 'regirock', 'registeel',
  'regice', 'latias', 'latios', 'kyogre', 'groudon', 'rayquaza', 'deoxys',
  'uxie', 'mesprit', 'azelf', 'dialga', 'palkia', 'regigigas', 'giratina',
  'cresselia', 'phione', 'manaphy', 'darkrai', 'arceus', 'cobalion',
  'terrakion', 'virizion', 'tornadus', 'thundurus', 'reshiram', 'zekrom',
  'landorus', 'kyurem', 'keldeo', 'meloetta', 'genesect'
]);

if (!fsSync.existsSync(outputDir)) {
  fsSync.mkdirSync(outputDir, { recursive: true });
}

// Fetches all Pokémon data (name and sprite URL) from PokeAPI
async function fetchAllPokemonData() {
  const pokemonData = {};
  console.log(`Fetching data for up to ${TOTAL_POKEMON_GEN5} Pokémon from PokeAPI...`);

  for (let i = 1; i <= TOTAL_POKEMON_GEN5; i++) {
    try {
      const response = await axios.get(`${POKEAPI_BASE_URL}/${i}`);
      const pokemon = response.data;
      const name = pokemon.name;

      // Check if the Pokémon name starts with any of the excluded names
      // This handles different forms (e.g., 'tornadus-incarnate' starts with 'tornadus')
      const isExcluded = [...EXCLUDED_POKEMON].some(excludedName => name.startsWith(excludedName));

      if (isExcluded) {
        process.stdout.write(`Skipping excluded Pokémon: #${i} ${name}         \n`);
        continue;
      }
      
      const spriteUrl = pokemon.sprites.front_default;

      if (spriteUrl) {
        pokemonData[name] = spriteUrl;
        process.stdout.write(`Fetched: #${i} ${name}                       \r`);
      } else {
        console.log(`\nWarning: No sprite found for #${i} ${name}`);
      }
    } catch (error) {
      console.error(`\nError: Failed to fetch data for Pokémon with ID ${i}.`);
    }
  }
  process.stdout.write('\n');
  console.log(`Successfully fetched data for ${Object.keys(pokemonData).length} Pokémon.`);
  return pokemonData;
}

// Downloads and crops a single sprite image
async function downloadAndCrop(pokemonName, url) {
  try {
    const response = await axios({
      url,
      method: 'GET',
      responseType: 'arraybuffer',
    });

    const buffer = Buffer.from(response.data, 'binary');
    const fileName = `${pokemonName.toLowerCase()}.png`;
    const outputPath = path.join(outputDir, fileName);

    await sharp(buffer).trim().toFile(outputPath);
  } catch (error) {
    // Log specific error without stopping the entire process
    console.error(`\nError processing sprite for ${pokemonName}: ${error.message}`);
  }
}

// Generates the `src/data/pokemon-data.ts` file
async function generatePokemonDataFile(pokemonData) {
  console.log('Generating pokemon-data.ts...');

  const capitalizedPokemonNames = Object.keys(pokemonData).map(name =>
    name.split('-').map(part => part.charAt(0).toUpperCase() + part.slice(1)).join('-')
  );

  const pokemonSpritesObject = capitalizedPokemonNames.reduce((acc, name) => {
    // The key is capitalized, but the URL points to the lowercase filename
    acc[name] = `${SUPABASE_SPRITE_URL_BASE}${name.toLowerCase()}.png`;
    return acc;
  }, {});

  const fileContent = `// This file is auto-generated by scripts/download-sprites.js
// Do not edit this file manually.

export const POKEMON_NAMES = ${JSON.stringify(capitalizedPokemonNames, null, 2)};

export const POKEMON_SPRITES: Record<string, string> = ${JSON.stringify(pokemonSpritesObject, null, 2)};
`;

  await fs.writeFile(dataFilePath, fileContent);
  console.log(`Successfully generated ${dataFilePath}`);
}

// Main function to orchestrate the process
async function main() {
  // 1. Fetch all data from the API
  const pokemonData = await fetchAllPokemonData();

  // 2. Download and crop all sprites in batches
  console.log('Downloading and cropping sprites...');
  const allDownloads = Object.entries(pokemonData).map(([name, url]) => 
    downloadAndCrop(name, url)
  );

  for (let i = 0; i < allDownloads.length; i += DOWNLOAD_CONCURRENCY) {
    const batch = allDownloads.slice(i, i + DOWNLOAD_CONCURRENCY);
    await Promise.all(batch);
    const progress = Math.min(i + DOWNLOAD_CONCURRENCY, allDownloads.length);
    process.stdout.write(`Processed ${progress} / ${allDownloads.length} sprites... \r`);
  }
  process.stdout.write('\n');
  console.log('All sprites have been downloaded and cropped.');

  // 3. Generate the TypeScript data file for the application
  await generatePokemonDataFile(pokemonData);

  // 4. Provide next steps
  console.log('\n✅ Process Complete!');
  console.log('\nPlease follow these next steps:');
  console.log('1. Run `node scripts/upload-sprites.js` to upload the new sprites to Supabase.');
  console.log('2. After the upload is complete, I will refactor the app to use the new data.');
}

main(); 